<?xml version="1.0" encoding="UTF-8"?>
<init>
  <chapter name="Introduction" >
    <text>    Hello!

     Here is a Go language interactive tutorial, interactive - because you can edit the code and then execute it immedeately to see the results of your changes.

     The tutorial is very simple to navigate, it has minimum of tools. Just click on a tree node to see appropriate content in a text editor. If this is a code fragment, clicking on a '>' button, which is in a right top corner of a window above the editor will execute this code. The "Fmt" button uses gofmt program to format the code in the editor window. '+', '-' buttons are intended to increase/decrease a font size in the editor window.

     Thanks for your attention.
     Alexander S.Kresin.

    </text>
  </chapter>
  <chapter name="A Tour of Go" >
    <text>This is an abbreviated Tour of Go from the official cite: https://tour.golang.org/welcome/1
    </text>
    <chapter name="Packages, variables and functions" >
      <module name = "Packages">
        <code><![CDATA[/* Every Go program is made up of packages.
Programs start running in package main.
This program is using the packages with import paths "fmt" and "string".
By convention, the package name is the same as the last element of the
import path. For instance, the "math/rand" package comprises files that
begin with the statement package rand. */
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "test"
	n := strings.Index(s,"s")
	fmt.Println(s[:n])
	fmt.Println(s[n+1:])
}]]>
        </code>
      </module>
      <module name = "Exported names">
        <code><![CDATA[/* In Go, a name is exported if it begins with a capital letter. For example,
Pizza is an exported name, as is Pi, which is exported from the math package.
pizza and pi do not start with a capital letter, so they are not exported.
When importing a package, you can refer only to its exported names. Any
"unexported" names are not accessible from outside the package.
Run the code. Notice the error message.
To fix the error, rename math.pi to math.Pi and try it again. */
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}]]>
        </code>
      </module>
      <module name = "Functions">
        <code><![CDATA[/* A function can take zero or more arguments.
In this example, add takes two parameters of type int.
Notice that the type comes after the variable name.
When two or more consecutive named function parameters share a type, you can
omit the type from all but the last - as in sub() function in this example. */
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}

func main() {
	fmt.Println(add(42, 13))
	fmt.Println(sub(42, 13))
}]]>
        </code>
      </module>
      <module name = "Multiple results">
        <code><![CDATA[/* A function can return any number of results.
The swap() function returns two strings. 
Go's return values may be named. If so, they are treated as variables
defined at the top of the function - see split() function.
These names should be used to document the meaning of the return values.
A return statement without arguments returns the named return values.
This is known as a "naked" return.
Naked return statements should be used only in short functions, as with
the example shown here. They can harm readability in longer functions. */
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
	fmt.Println(split(17))
}]]>
        </code>
      </module>
      <module name = "Variables">
        <code><![CDATA[/* The var statement declares a list of variables; as in function argument lists, the type is last.
A var statement can be at package or function level. We see both in this example.
A var declaration can include initializers, one per variable.
If an initializer is present, the type can be omitted; the variable
will take the type of the initializer.
Inside a function, the := short assignment statement can be used in place
of a var declaration with implicit type.
Outside a function, every statement begins with a keyword
(var, func, and so on) and so the := construct is not available. */
package main

import "fmt"

var c, python, java bool

func main() {
	var i, j = 1, 2

	x := 10
	fmt.Println(i, j, x, c, python, java)
}]]>
        </code>
      </module>
      <module name = "Basic types">
        <code><![CDATA[/*  Go's basic types are
bool
string
int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr
byte // alias for uint8
rune // alias for int32
     // represents a Unicode code point
float32 float64
complex64 complex128

The example shows variables of several types, and also that variable
declarations may be "factored" into blocks, as with import statements.
The int, uint, and uintptr types are usually 32 bits wide on 32-bit systems
and 64 bits wide on 64-bit systems. When you need an integer value you should
use int unless you have a specific reason to use a sized or unsigned integer type. */
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe   bool       = false
	MaxInt uint64     = 1<<64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
	fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value: %v\n", z, z)
}]]>
        </code>
      </module>
      <module name = "Zero values">
        <code><![CDATA[/*  Variables declared without an explicit initial value are given their zero value.
The zero value is:

    0 for numeric types,
    false for the boolean type, and
    "" (the empty string) for strings. */
package main

import "fmt"

func main() {
	var i int
	var f float64
	var b bool
	var s string
	fmt.Printf("%v %v %v %q\n", i, f, b, s)
}]]>
        </code>
      </module>
      <module name = "Type conversions">
        <code><![CDATA[/*  The expression T(v) converts the value v to the type T.
Some numeric conversions:
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

Or, put more simply:
i := 42
f := float64(i)
u := uint(f)

Unlike in C, in Go assignment between items of different type requires an explicit
conversion. Try removing the float64 or uint conversions in the example and see what happens. */
package main

import (
	"fmt"
	"math"
)

func main() {
	var x, y int = 3, 4
	var f float64 = math.Sqrt(float64(x*x + y*y))
	var z uint = uint(f)
	fmt.Println(x, y, z)
}]]>
        </code>
      </module>
      <module name = "Type inference">
        <code><![CDATA[/* When declaring a variable without specifying an explicit type
(either by using the := syntax or var = expression syntax), the variable's type
is inferred from the value on the right hand side. When the right hand side of
the declaration is typed, the new variable is of that same type:

var i int
j := i // j is an int

But when the right hand side contains an untyped numeric constant, the new variable
may be an int, float64, or complex128 depending on the precision of the constant:

i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128

Try changing the initial value of v in the example code and observe how its type is affected. */
package main

import "fmt"

func main() {
	v := 42 // change me!
	fmt.Printf("v is of type %T\n", v)
}]]>
        </code>
      </module>
      <module name = "Constants">
        <code><![CDATA[/*  Constants are declared like variables, but with the const keyword.
Constants can be character, string, boolean, or numeric values.
Constants cannot be declared using the := syntax.
Numeric constants are high-precision values.
An untyped constant takes the type needed by its context.
Try printing needInt(Big) too.
(An int can store at maximum a 64-bit integer, and sometimes less.) */
package main

import "fmt"

const Pi = 3.14

const (
	// Create a huge number by shifting a 1 bit left 100 places.
	// In other words, the binary number that is 1 followed by 100 zeroes.
	Big = 1 << 100
	// Shift it right again 99 places, so we end up with 1<<1, or 2.
	Small = Big >> 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x * 0.1
}

func main() {
	const World = "Мир"
	fmt.Println("Hello", World)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)

	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}]]>
        </code>
      </module>
    </chapter>
    <chapter name="for, if, switch,..." >
      <module name = "For">
        <code><![CDATA[/*  Go has only one looping construct, the for loop.
The basic for loop has three components separated by semicolons:

    the init statement: executed before the first iteration
    the condition expression: evaluated before every iteration
    the post statement: executed at the end of every iteration

The init statement will often be a short variable declaration, and the
variables declared there are visible only in the scope of the for statement.
The loop will stop iterating once the boolean condition evaluates to false.
Note: Unlike other languages like C, Java, or JavaScript there are no parentheses
surrounding the three components of the for statement and the braces { } are always required. */
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)

	// The init and post statements are optional.
	sum = 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)

	// At that point you can drop the semicolons: C's while is spelled for in Go.
	sum = 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}]]>
        </code>
      </module>
      <module name = "If">
        <code><![CDATA[/* Go's if statements are like its for loops; the expression need not
be surrounded by parentheses ( ) but the braces { } are required.
Like for, the if statement can start with a short statement to execute before the condition.
Variables declared by the statement are only in scope until the end of the if,
but are also available inside any of the else blocks. */
package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// can't use v here, though
	return lim
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
	fmt.Println(pow(3, 2, 10), pow(3, 3, 20),)
}]]>
        </code>
      </module>
    </chapter>
  </chapter>
  <chapter name="Go by Example" >
    <text>This section contains code samples from the cite "Go by Example": https://gobyexample.com/
    </text>
  </chapter>
  <chapter name="External GUI" >
    <text>This section is about the External - GUI framework, based on using the GuiServer, external standalone application, which provides GUI service.
This program, Golang Tutor, is written, using this framework.
    </text>
    <module name = "Main window">
      <code><![CDATA[
package main

import (
	egui "github.com/alkresin/external"
)

func main() {

	if egui.Init("") != 0 {
		return
	}

	pWindow := &(egui.Widget{X: 100, Y: 100, W: 400, H: 280, Title: "External"})
	egui.InitMainWindow(pWindow)

	pWindow.Activate()
	egui.Exit()

}]]>
      </code>
    </module>
  </chapter>
</init>