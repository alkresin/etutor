<?xml version="1.0" encoding="UTF-8"?>
<init>
  <chapter name="Introduction" >
    <text>    Hello!

     Here is a Go language interactive tutorial, interactive - because you can edit the code and then execute it immedeately to see the results of your changes.

     The tutorial is very simple to navigate, it has minimum of tools. Just click on a tree node to see appropriate content in a text editor. If this is a code fragment, clicking on a '>' button, which is in a right top corner of a window above the editor will execute this code. The "Fmt" button uses gofmt program to format the code in the editor window. '+', '-' buttons are intended to increase/decrease a font size in the editor window.

     Thanks for your attention.
     Alexander S.Kresin.

    </text>
  </chapter>
  <chapter name="A Tour of Go" >
    <text>This is an abbreviated Tour of Go from the official cite: https://tour.golang.org/welcome/1
    </text>
    <chapter name="Packages, variables and functions" >
      <module name = "Packages">
        <code><![CDATA[/* Every Go program is made up of packages.
Programs start running in package main.
This program is using the packages with import paths "fmt" and "string".
By convention, the package name is the same as the last element of the
import path. For instance, the "math/rand" package comprises files that
begin with the statement package rand. */
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "test"
	n := strings.Index(s,"s")
	fmt.Println(s[:n])
	fmt.Println(s[n+1:])
}]]>
        </code>
      </module>
      <module name = "Exported names">
        <code><![CDATA[/* In Go, a name is exported if it begins with a capital letter. For example,
Pizza is an exported name, as is Pi, which is exported from the math package.
pizza and pi do not start with a capital letter, so they are not exported.
When importing a package, you can refer only to its exported names. Any
"unexported" names are not accessible from outside the package.
Run the code. Notice the error message.
To fix the error, rename math.pi to math.Pi and try it again. */
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}]]>
        </code>
      </module>
      <module name = "Functions">
        <code><![CDATA[/* A function can take zero or more arguments.
In this example, add takes two parameters of type int.
Notice that the type comes after the variable name.
When two or more consecutive named function parameters share a type, you can
omit the type from all but the last - as in sub() function in this example. */
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}

func main() {
	fmt.Println(add(42, 13))
	fmt.Println(sub(42, 13))
}]]>
        </code>
      </module>
      <module name = "Multiple results">
        <code><![CDATA[/* A function can return any number of results.
The swap() function returns two strings. 
Go's return values may be named. If so, they are treated as variables
defined at the top of the function - see split() function.
These names should be used to document the meaning of the return values.
A return statement without arguments returns the named return values.
This is known as a "naked" return.
Naked return statements should be used only in short functions, as with
the example shown here. They can harm readability in longer functions. */
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
	fmt.Println(split(17))
}]]>
        </code>
      </module>
      <module name = "Variables">
        <code><![CDATA[/* The var statement declares a list of variables; as in function argument lists, the type is last.
A var statement can be at package or function level. We see both in this example.
A var declaration can include initializers, one per variable.
If an initializer is present, the type can be omitted; the variable
will take the type of the initializer.
Inside a function, the := short assignment statement can be used in place
of a var declaration with implicit type.
Outside a function, every statement begins with a keyword
(var, func, and so on) and so the := construct is not available. */
package main

import "fmt"

var c, python, java bool

func main() {
	var i, j = 1, 2

	x := 10
	fmt.Println(i, j, x, c, python, java)
}]]>
        </code>
      </module>
      <module name = "Basic types">
        <code><![CDATA[/*  Go's basic types are
bool
string
int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr
byte // alias for uint8
rune // alias for int32
     // represents a Unicode code point
float32 float64
complex64 complex128

The example shows variables of several types, and also that variable
declarations may be "factored" into blocks, as with import statements.
The int, uint, and uintptr types are usually 32 bits wide on 32-bit systems
and 64 bits wide on 64-bit systems. When you need an integer value you should
use int unless you have a specific reason to use a sized or unsigned integer type. */
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe   bool       = false
	MaxInt uint64     = 1<<64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
	fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value: %v\n", z, z)
}]]>
        </code>
      </module>
      <module name = "Zero values">
        <code><![CDATA[/*  Variables declared without an explicit initial value are given their zero value.
The zero value is:

    0 for numeric types,
    false for the boolean type, and
    "" (the empty string) for strings. */
package main

import "fmt"

func main() {
	var i int
	var f float64
	var b bool
	var s string
	fmt.Printf("%v %v %v %q\n", i, f, b, s)
}]]>
        </code>
      </module>
      <module name = "Type conversions">
        <code><![CDATA[/*  The expression T(v) converts the value v to the type T.
Some numeric conversions:
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

Or, put more simply:
i := 42
f := float64(i)
u := uint(f)

Unlike in C, in Go assignment between items of different type requires an explicit
conversion. Try removing the float64 or uint conversions in the example and see what happens. */
package main

import (
	"fmt"
	"math"
)

func main() {
	var x, y int = 3, 4
	var f float64 = math.Sqrt(float64(x*x + y*y))
	var z uint = uint(f)
	fmt.Println(x, y, z)
}]]>
        </code>
      </module>
      <module name = "Type inference">
        <code><![CDATA[/* When declaring a variable without specifying an explicit type
(either by using the := syntax or var = expression syntax), the variable's type
is inferred from the value on the right hand side. When the right hand side of
the declaration is typed, the new variable is of that same type:

var i int
j := i // j is an int

But when the right hand side contains an untyped numeric constant, the new variable
may be an int, float64, or complex128 depending on the precision of the constant:

i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128

Try changing the initial value of v in the example code and observe how its type is affected. */
package main

import "fmt"

func main() {
	v := 42 // change me!
	fmt.Printf("v is of type %T\n", v)
}]]>
        </code>
      </module>
      <module name = "Constants">
        <code><![CDATA[/*  Constants are declared like variables, but with the const keyword.
Constants can be character, string, boolean, or numeric values.
Constants cannot be declared using the := syntax.
Numeric constants are high-precision values.
An untyped constant takes the type needed by its context.
Try printing needInt(Big) too.
(An int can store at maximum a 64-bit integer, and sometimes less.) */
package main

import "fmt"

const Pi = 3.14

const (
	// Create a huge number by shifting a 1 bit left 100 places.
	// In other words, the binary number that is 1 followed by 100 zeroes.
	Big = 1 << 100
	// Shift it right again 99 places, so we end up with 1<<1, or 2.
	Small = Big >> 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x * 0.1
}

func main() {
	const World = "Мир"
	fmt.Println("Hello", World)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)

	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}]]>
        </code>
      </module>
    </chapter>
    <chapter name="for, if, switch,..." >
      <module name = "For">
        <code><![CDATA[/*  Go has only one looping construct, the for loop.
The basic for loop has three components separated by semicolons:

    the init statement: executed before the first iteration
    the condition expression: evaluated before every iteration
    the post statement: executed at the end of every iteration

The init statement will often be a short variable declaration, and the
variables declared there are visible only in the scope of the for statement.
The loop will stop iterating once the boolean condition evaluates to false.
Note: Unlike other languages like C, Java, or JavaScript there are no parentheses
surrounding the three components of the for statement and the braces { } are always required. */
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)

	// The init and post statements are optional.
	sum = 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)

	// At that point you can drop the semicolons: C's while is spelled for in Go.
	sum = 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}]]>
        </code>
      </module>
      <module name = "If...else">
        <code><![CDATA[/* Go's if statements are like its for loops; the expression need not
be surrounded by parentheses ( ) but the braces { } are required.
Like for, the if statement can start with a short statement to execute before the condition.
Variables declared by the statement are only in scope until the end of the if,
but are also available inside any of the else blocks. */
package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// can't use v here, though
	return lim
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
	fmt.Println(pow(3, 2, 10), pow(3, 3, 20),)
}]]>
        </code>
      </module>
      <module name = "Switch">
        <code><![CDATA[/*  A switch statement is a shorter way to write a sequence of if - else
statements. It runs the first case whose value is equal to the condition expression.

Go's switch is like the one in C, C++, Java, JavaScript, and PHP, except that Go only
runs the selected case, not all the cases that follow. In effect, the break statement
that is needed at the end of each case in those languages is provided automatically in Go.
Another important difference is that Go's switch cases need not be constants, and
the values involved need not be integers.
Switch cases evaluate cases from top to bottom, stopping when a case succeeds. */
package main

import (
	"fmt"
	"time"
	"runtime"
)

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.", os)
	}

	// Note: Time in the Go playground always appears to start at 2009-11-10 23:00:00 UTC,
	// a value whose significance is left as an exercise for the reader. 
	fmt.Println("\r\nWhen's Saturday? ")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today + 0:
		fmt.Println("Today.")
	case today + 1:
		fmt.Println("Tomorrow.")
	case today + 2:
		fmt.Println("In two days.")
	default:
		fmt.Println("Too far away.")
	}

	// Switch without a condition is the same as switch true.
    // This construct can be a clean way to write long if-then-else chains.
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("\r\nGood morning!")
	case t.Hour() < 17:
		fmt.Println("\r\nGood afternoon.")
	default:
		fmt.Println("\r\nGood evening.")
	}
}]]>
        </code>
      </module>
      <module name = "Defer">
        <code><![CDATA[/* A defer statement defers the execution of a function until the
surrounding function returns. The deferred call's arguments are evaluated immediately,
but the function call is not executed until the surrounding function returns.
Deferred function calls are pushed onto a stack. When a function returns,
its deferred calls are executed in last-in-first-out order. */
package main

import "fmt"

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}]]>
        </code>
      </module>
    </chapter>
    <chapter name="More types" >
      <module name = "Pointers">
        <code><![CDATA[ /*  Go has pointers. A pointer holds the memory address of a value.
The type *T is a pointer to a T value. Its zero value is nil.

var p *int

The & operator generates a pointer to its operand.

i := 42
p = &i

The * operator denotes the pointer's underlying value.

fmt.Println(*p) // read i through the pointer p
*p = 21         // set i through the pointer p

This is known as "dereferencing" or "indirecting".
Unlike C, Go has no pointer arithmetic. */
package main

import "fmt"

func main() {
	i, j := 42, 2701

	p := &i         // point to i
	fmt.Println(*p) // read i through the pointer
	*p = 21         // set i through the pointer
	fmt.Println(i)  // see the new value of i

	p = &j         // point to j
	*p = *p / 37   // divide j through the pointer
	fmt.Println(j) // see the new value of j
}]]>
        </code>
      </module>
      <module name = "Structs">
        <code><![CDATA[ /* A struct is a collection of fields.
Struct fields are accessed using a dot, but can be accessed through a struct pointer, too.
To access the field X of a struct when we have the struct pointer p we could write (*p).X.
However, that notation is cumbersome, so the language permits us instead to write just p.X,
without the explicit dereference.
A struct literal denotes a newly allocated struct value by listing the values of its fields.
You can list just a subset of fields by using the Name: syntax.
(And the order of named fields is irrelevant.)
The special prefix & returns a pointer to the struct value. */
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

var (
	v1 = Vertex{1, 2}  // has type Vertex
	v2 = Vertex{X: 1}  // Y:0 is implicit
	v3 = Vertex{}      // X:0 and Y:0
	p  = &Vertex{1, 2} // has type *Vertex
)

func main() {
	fmt.Println(v1, p, v2, v3)
	v1.X = 4
	fmt.Println(v1.X)
	fmt.Println(v1)
	p1 := &v1
	p1.X = 1e9
	fmt.Println(v1)
}]]>
        </code>
      </module>
      <module name = "Arrays">
        <code><![CDATA[ /*  The type [n]T is an array of n values of type T.
The expression
var a [10]int
declares a variable a as an array of ten integers.
An array's length is part of its type, so arrays cannot be resized.
This seems limiting, but don't worry; Go provides a convenient way of working with arrays - slices. */
package main

import "fmt"

func main() {
	var a [2]string
	a[0] = "Hello"
	a[1] = "World"
	fmt.Println(a[0], a[1])
	fmt.Println(a)

	primes := [6]int{2, 3, 5, 7, 11, 13}
	fmt.Println(primes)
}]]>
        </code>
      </module>
      <module name = "Slices">
        <code><![CDATA[ /* An array has a fixed size. A slice, on the other hand, is
a dynamically-sized, flexible view into the elements of an array. In practice,
slices are much more common than arrays.
The type []T is a slice with elements of type T.
A slice is formed by specifying two indices, a low and high bound, separated by a colon:
a[low : high]
This selects a half-open range which includes the first element, but excludes the last one.
The following expression creates a slice which includes elements 1 through 3 of a:
a[1:4]
A slice literal is like an array literal without the length.
This is an array literal:
[3]bool{true, true, false}
And this creates the same array as above, then builds a slice that references it:
[]bool{true, true, false}
Slices can contain any type, including other slices. */
package main

import "fmt"
import "strings"

func main() {
	primes := [6]int{2, 3, 5, 7, 11, 13}

	var s1 []int = primes[1:4]
	fmt.Println(s1)

	q := []int{2, 3, 5, 7, 11, 13}
	fmt.Println(q)

	r := []bool{true, false, true, true, false, true}
	fmt.Println(r)

	s := []struct {
		i int
		b bool
	} {
		{2, true}, {3, false}, {5, true}, {7, true},
	}
	fmt.Println(s)

	// Create a tic-tac-toe board.
	board := [][]string{
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
	}

	// The players take turns.
	board[0][0] = "X"
	board[2][2] = "O"
	board[1][2] = "X"
	board[1][0] = "O"
	board[0][2] = "X"

	for i := 0; i < len(board); i++ {
		fmt.Printf("%s\n", strings.Join(board[i], " "))
	}
}]]>
        </code>
      </module>
      <module name = "Slices - continue">
        <code><![CDATA[ /* A slice does not store any data, it just describes a section of
an underlying array. Changing the elements of a slice modifies the corresponding
elements of its underlying array.
Other slices that share the same underlying array will see those changes.
When slicing, you may omit the high or low bounds to use their defaults instead.
The default is zero for the low bound and the length of the slice for the high bound.
For the array
var a [10]int
these slice expressions are equivalent:
a[0:10]
a[:10]
a[0:]
a[:] */
package main

import "fmt"

func main() {
	names := [4]string{
		"John",
		"Paul",
		"George",
		"Ringo",
	}
	fmt.Println(names)

	a := names[0:2]
	b := names[1:3]
	fmt.Println(a, b)

	b[0] = "XXX"
	fmt.Println(a, b)
	fmt.Println(names)

	s := []int{2, 3, 5, 7, 11, 13}
	s = s[1:4]
	fmt.Println(s)

	s = s[:2]
	fmt.Println(s)

	s = s[1:]
	fmt.Println(s)
}]]>
        </code>
      </module>
      <module name = "Slices - len and capacity">
        <code><![CDATA[ /* A slice has both a length and a capacity.
The length of a slice is the number of elements it contains.
The capacity of a slice is the number of elements in the underlying array,
counting from the first element in the slice.
The length and capacity of a slice s can be obtained using the expressions len(s) and cap(s).
You can extend a slice's length by re-slicing it, provided it has sufficient capacity.
Try changing one of the slice operations in the example program to extend it
beyond its capacity and see what happens. */
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	printSlice(s)

	// Slice the slice to give it zero length.
	s = s[:0]
	printSlice(s)

	// Extend its length.
	s = s[:4]
	printSlice(s)

	// Drop its first two values.
	s = s[2:]
	printSlice(s)

	// The zero value of a slice is nil.
	// A nil slice has a length and capacity of 0 and has no underlying array.
	var s1 []int
	fmt.Println(s1, len(s1), cap(s1))
	if s1 == nil {
		fmt.Println("nil!")
	}
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}]]>
        </code>
      </module>
      <module name = "Slices - make">
        <code><![CDATA[ /* Slices can be created with the built-in make function;
this is how you create dynamically-sized arrays.
The make function allocates a zeroed array and returns a slice that refers to that array:
a := make([]int, 5)  // len(a)=5
To specify a capacity, pass a third argument to make:
b := make([]int, 0, 5) // len(b)=0, cap(b)=5
b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4 */
package main

import "fmt"

func main() {
	a := make([]int, 5)
	printSlice("a", a)

	b := make([]int, 0, 5)
	printSlice("b", b)

	c := b[:2]
	printSlice("c", c)

	d := c[2:5]
	printSlice("d", d)
}

func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}]]>
        </code>
      </module>
      <module name = "Range">
        <code><![CDATA[ /* The range form of the for loop iterates over a slice or map.
When ranging over a slice, two values are returned for each iteration.
The first is the index, and the second is a copy of the element at that index.
You can skip the index or value by assigning to _.
If you only want the index, drop the , value entirely. */
package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
		fmt.Printf("2**%d = %d\n", i, v)
	}
	pow := make([]int, 10)
	for i := range pow {
		pow[i] = 1 << uint(i) // == 2**i
	}
	for _, value := range pow {
		fmt.Printf("%d\n", value)
	}
}]]>
        </code>
      </module>
      <module name = "Maps">
        <code><![CDATA[ /* A map maps keys to values.
The zero value of a map is nil. A nil map has no keys, nor can keys be added.
The make function returns a map of the given type, initialized and ready for use. 
Map literals are like struct literals, but the keys are required. */
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m1 map[string]Vertex
var m2 = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}
// If the top-level type is just a type name, you can omit it from the elements of the literal. 
var m3 = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	m1 = make(map[string]Vertex)
	m1["Bell Labs"] = Vertex{
		40.68433, -74.39967,
	}
	fmt.Println(m1["Bell Labs"])
	fmt.Println(m2)
	fmt.Println(m3)
}]]>
        </code>
      </module>
      <module name = "Mutating mps">
        <code><![CDATA[ /* Insert or update an element in map m:
m[key] = elem
Retrieve an element:
elem = m[key]
Delete an element:
delete(m, key)
Test that a key is present with a two-value assignment:
elem, ok = m[key]
If key is in m, ok is true. If not, ok is false.
If key is not in the map, then elem is the zero value for the map's element type.
Note: If elem or ok have not yet been declared you could use a short declaration form:
elem, ok := m[key] */
package main

import "fmt"

func main() {
	m := make(map[string]int)

	m["Answer"] = 42
	fmt.Println("The value:", m["Answer"])

	m["Answer"] = 48
	fmt.Println("The value:", m["Answer"])

	delete(m, "Answer")
	fmt.Println("The value:", m["Answer"])

	v, ok := m["Answer"]
	fmt.Println("The value:", v, "Present?", ok)
}]]>
        </code>
      </module>
      <module name = "Function values">
        <code><![CDATA[ /* Functions are values too. They can be passed around just like other values.
Function values may be used as function arguments and return values. */
package main

import (
	"fmt"
	"math"
)

func compute(fn func(float64, float64) float64) float64 {
	return fn(3, 4)
}

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}
	fmt.Println(hypot(5, 12))

	fmt.Println(compute(hypot))
	fmt.Println(compute(math.Pow))
}]]>
        </code>
      </module>
      <module name = "Function closures">
        <code><![CDATA[ /* Go functions may be closures. A closure is a function value that
references variables from outside its body. The function may access and assign
to the referenced variables; in this sense the function is "bound" to the variables.
For example, the adder function returns a closure. Each closure is bound to its own sum variable. */
package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}]]>
        </code>
      </module>
    </chapter>
  </chapter>
  <chapter name="Go by Example" >
    <text>The section contains code samples from the "Go by Example" site: https://gobyexample.com/
This work is copyright Mark McGranaghan and licensed under a 
Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/
    </text>
    <chapter name="Basics" >
    <text>
    </text>
      <module name = "Variables">
        <code><![CDATA[package main

import "fmt"

func main() {

	// var declares 1 or more variables.
	var a = "initial"
	fmt.Println(a)

	// You can declare multiple variables at once.
	var b, c int = 1, 2
	fmt.Println(b, c)

	// Go will infer the type of initialized variables.
	var d = true
	fmt.Println(d)

	// Variables declared without a corresponding initialization are zero-valued.
	// For example, the zero value for an int is 0.
	var e int
	fmt.Println(e)

	// The := syntax is shorthand for declaring and initializing a variable,
	// e.g. for var f string = "short" in this case.
	f := "short"
	fmt.Println(f)
}]]>
        </code>
      </module>
      <module name = "Constants">
        <code><![CDATA[// Go supports constants of character, string, boolean, and numeric values.
package main

import "fmt"
import "math"

// const declares a constant value.
const s string = "constant"

func main() {
	fmt.Println(s)

	// A const statement can appear anywhere a var statement can.
	const n = 500000000

	// Constant expressions perform arithmetic with arbitrary precision.
	const d = 3e20 / n
	fmt.Println(d)

	// A numeric constant has no type until it’s given one, such as by an explicit cast.
	fmt.Println(int64(d))

	// A number can be given a type by using it in a context that requires one,
	// such as a variable assignment or function call. For example, here math.Sin expects a float64.
	fmt.Println(math.Sin(n))
}]]>
        </code>
      </module>
      <module name = "For">
        <code><![CDATA[// for is Go’s only looping construct. Here are three basic types of for loops.
package main

import "fmt"

func main() {

	// The most basic type, with a single condition.
	i := 1
	for i <= 3 {
		fmt.Println(i)
		i = i + 1
	}

	// A classic initial/condition/after for loop.
	for j := 7; j <= 9; j++ {
	fmt.Println(j)
	}

	// for without a condition will loop repeatedly until you break out of the
	// loop or return from the enclosing function.
	for {
		fmt.Println("loop")
	break
	}

	// You can also continue to the next iteration of the loop.
	for n := 0; n <= 5; n++ {
		if n%2 == 0 {
			continue
		}
		fmt.Println(n)
	}
}]]>
        </code>
      </module>
      <module name = "If...else">
        <code><![CDATA[// Branching with if and else in Go is straight-forward.
package main
import "fmt"

func main() {

	//Here’s a basic example.
	if 7%2 == 0 {
		fmt.Println("7 is even")
	} else {
		fmt.Println("7 is odd")
	}

	//You can have an if statement without an else.
	if 8%4 == 0 {
		fmt.Println("8 is divisible by 4")
	}
	// A statement can precede conditionals; any variables declared in this
	// statement are available in all branches.
	if num := 9; num < 0 {
		fmt.Println(num, "is negative")
	} else if num < 10 {
		fmt.Println(num, "has 1 digit")
	} else {
	fmt.Println(num, "has multiple digits")
	}
}
// Note that you don’t need parentheses around conditions in Go, but that the braces are required.
// There is no ternary if in Go, so you’ll need to use a full if statement even for basic conditions.
]]>
        </code>
      </module>
      <module name = "Switch">
        <code><![CDATA[// Branching with if and else in Go is straight-forward.
// Switch statements express conditionals across many branches.
package main

import "fmt"
import "time"

func main() {

	// Here’s a basic switch.
	i := 2
	fmt.Print("Write ", i, " as ")
	switch i {
		case 1:
		fmt.Println("one")
	case 2:
		fmt.Println("two")
	case 3:
		fmt.Println("three")
	}

	// You can use commas to separate multiple expressions in the same case statement.
	// We use the optional default case in this example as well.
	switch time.Now().Weekday() {
	case time.Saturday, time.Sunday:
		fmt.Println("It's the weekend")
	default:
		fmt.Println("It's a weekday")
	}

	// switch without an expression is an alternate way to express if/else logic.
	// Here we also show how the case expressions can be non-constants.
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("It's before noon")
	default:
	fmt.Println("It's after noon")
	}

	// A type switch compares types instead of values.
	// You can use this to discover the type of an interface value.
	// In this example, the variable t will have the type corresponding to its clause.
	whatAmI := func(i interface{}) {
		switch t := i.(type) {
		case bool:
			fmt.Println("I'm a bool")
		case int:
			fmt.Println("I'm an int")
		default:
			fmt.Printf("Don't know type %T\n", t)
		}
	}
	whatAmI(true)
	whatAmI(1)
	whatAmI("hey")
}
]]>
        </code>
      </module>
      <module name = "Array">
        <code><![CDATA[// In Go, an array is a numbered sequence of elements of a specific length.
package main

import "fmt"

func main() {

	// Here we create an array a that will hold exactly 5 ints.
	// The type of elements and length are both part of the array’s type.
	// By default an array is zero-valued, which for ints means 0s.
	var a [5]int
	fmt.Println("emp:", a)

	// We can set a value at an index using the array[index] = value syntax,
	// and get a value with array[index].
	a[4] = 100
	fmt.Println("set:", a)
	fmt.Println("get:", a[4])

	// The builtin len returns the length of an array.
	fmt.Println("len:", len(a))

	// Use this syntax to declare and initialize an array in one line.
	b := [5]int{1, 2, 3, 4, 5}
	fmt.Println("dcl:", b)

	// Array types are one-dimensional, but you can compose types to build
	// multi-dimensional data structures.
	var twoD [2][3]int
	for i := 0; i < 2; i++ {
		for j := 0; j < 3; j++ {
			twoD[i][j] = i + j
		}
	}
	fmt.Println("2d: ", twoD)
}

	// Note that arrays appear in the form [v1 v2 v3 ...] when printed with fmt.Println.
]]>
        </code>
      </module>
      <module name = "Slices">
        <code><![CDATA[// Slices are a key data type in Go, giving a more powerful interface to sequences than arrays.
package main

import "fmt"

func main() {

	// Unlike arrays, slices are typed only by the elements they contain (not
	// the number of elements). To create an empty slice with non-zero length,
	// use the builtin make. Here we make a slice of strings of length 3 (initially zero-valued).
	s := make([]string, 3)
	fmt.Println("emp:", s)

	// We can set and get just like with arrays.
	s[0] = "a"
	s[1] = "b"
	s[2] = "c"
	fmt.Println("set:", s)
	fmt.Println("get:", s[2])

	// len returns the length of the slice as expected.
	fmt.Println("len:", len(s))

	// In addition to these basic operations, slices support several more
	// that make them richer than arrays. One is the builtin append,
	// which returns a slice containing one or more new values. Note that
	// we need to accept a return value from append as we may get a new slice value.
	s = append(s, "d")
	s = append(s, "e", "f")
	fmt.Println("apd:", s)

	// Slices can also be copy’d. Here we create an empty slice c of the same
	// length as s and copy into c from s.
	c := make([]string, len(s))
	copy(c, s)
	fmt.Println("cpy:", c)

	// Slices support a “slice” operator with the syntax slice[low:high].
	// For example, this gets a slice of the elements s[2], s[3], and s[4].
	l := s[2:5]
	fmt.Println("sl1:", l)

	// This slices up to (but excluding) s[5].
	l = s[:5]
	fmt.Println("sl2:", l)

	// And this slices up from (and including) s[2].
	l = s[2:]
	fmt.Println("sl3:", l)

	// We can declare and initialize a variable for slice in a single line as well.
	t := []string{"g", "h", "i"}
	fmt.Println("dcl:", t)

	// Slices can be composed into multi-dimensional data structures.
	// The length of the inner slices can vary, unlike with multi-dimensional arrays.
	twoD := make([][]int, 3)
	for i := 0; i < 3; i++ {
		innerLen := i + 1
		twoD[i] = make([]int, innerLen)
	    for j := 0; j < innerLen; j++ {
			twoD[i][j] = i + j
		}
	}
	fmt.Println("2d: ", twoD)
}

// Note that while slices are different types than arrays, they are rendered similarly by fmt.Println.
]]>
        </code>
      </module>
      </chapter>
      <module name = "String functions">
        <code><![CDATA[ /* The standard library’s strings package provides many useful
string-related functions. Here are some examples to give you a sense of the package. */
package main

import s "strings"
import "fmt"

// We alias fmt.Println to a shorter name as we’ll use it a lot below.
var p = fmt.Println

func main() {

	// Here’s a sample of the functions available in strings.
	// Since these are functions from the package, not methods on the string
	// object itself, we need pass the string in question as the first argument
	// to the function. You can find more functions in the strings package docs.
	p("Contains:  ", s.Contains("test", "es"))
	p("Count:     ", s.Count("test", "t"))
	p("HasPrefix: ", s.HasPrefix("test", "te"))
	p("HasSuffix: ", s.HasSuffix("test", "st"))
	p("Index:     ", s.Index("test", "e"))
	p("Join:      ", s.Join([]string{"a", "b"}, "-"))
	p("Repeat:    ", s.Repeat("a", 5))
	p("Replace:   ", s.Replace("foo", "o", "0", -1))
	p("Replace:   ", s.Replace("foo", "o", "0", 1))
	p("Split:     ", s.Split("a-b-c-d-e", "-"))
	p("ToLower:   ", s.ToLower("TEST"))
	p("ToUpper:   ", s.ToUpper("test"))
	p()

	//Not part of strings, but worth mentioning here, are the mechanisms for getting the length of a string in bytes and getting a byte by index.
	p("Len: ", len("hello"))
	p("Char:", "hello"[1])
}

// Note that len and indexing above work at the byte level.
// Go uses UTF-8 encoded strings, so this is often useful as-is.
// If you’re working with potentially multi-byte characters you’ll want to use
// encoding-aware operations. See strings, bytes, runes and characters in Go for more information.
]]>
        </code>
      </module>
      <module name = "String formatting">
        <code><![CDATA[// Go offers excellent support for string formatting in the printf tradition.
// Here are some examples of common string formatting tasks.
package main

import "fmt"
import "os"

type point struct {
	x, y int
}

func main() {

	// Go offers several printing “verbs” designed to format general Go values. For example, this prints an instance of our point struct.
	p := point{1, 2}
	fmt.Printf("%v\n", p)

	// If the value is a struct, the %+v variant will include the struct’s field names.
	fmt.Printf("%+v\n", p)

	// The %#v variant prints a Go syntax representation of the value,
	// i.e. the source code snippet that would produce that value.
    fmt.Printf("%#v\n", p)

	// To print the type of a value, use %T.
	fmt.Printf("%T\n", p)

	// Formatting booleans is straight-forward.
	fmt.Printf("%t\n", true)

	// There are many options for formatting integers. Use %d for standard, base-10 formatting.
	fmt.Printf("%d\n", 123)

	// This prints a binary representation.
	fmt.Printf("%b\n", 14)

	// This prints the character corresponding to the given integer.
	fmt.Printf("%c\n", 33)

	// %x provides hex encoding.
	fmt.Printf("%x\n", 456)

	// There are also several formatting options for floats. For basic decimal formatting use %f.
	fmt.Printf("%f\n", 78.9)

	// %e and %E format the float in (slightly different versions of) scientific notation.
	fmt.Printf("%e\n", 123400000.0)
	fmt.Printf("%E\n", 123400000.0)

	// For basic string printing use %s.
	fmt.Printf("%s\n", "\"string\"")

	// To double-quote strings as in Go source, use %q.
	fmt.Printf("%q\n", "\"string\"")

	// As with integers seen earlier, %x renders the string in base-16,
	// with two output characters per byte of input.
	fmt.Printf("%x\n", "hex this")

	// To print a representation of a pointer, use %p.
	fmt.Printf("%p\n", &p)

	// When formatting numbers you will often want to control the width and
	// precision of the resulting figure. To specify the width of an integer,
	// use a number after the % in the verb. By default the result will be
	// right-justified and padded with spaces.
	fmt.Printf("|%6d|%6d|\n", 12, 345)

	// You can also specify the width of printed floats, though usually you’ll
	// also want to restrict the decimal precision at the same time with the width.precision syntax.
	fmt.Printf("|%6.2f|%6.2f|\n", 1.2, 3.45)

	// To left-justify, use the - flag.
	fmt.Printf("|%-6.2f|%-6.2f|\n", 1.2, 3.45)

	// You may also want to control width when formatting strings, especially
	// to ensure that they align in table-like output. For basic right-justified width.
	fmt.Printf("|%6s|%6s|\n", "foo", "b")

	// To left-justify use the - flag as with numbers.
	fmt.Printf("|%-6s|%-6s|\n", "foo", "b")

	// So far we’ve seen Printf, which prints the formatted string to os.Stdout.
	// Sprintf formats and returns a string without printing it anywhere.
	s := fmt.Sprintf("a %s", "string")
	fmt.Println(s)

	// You can format+print to io.Writers other than os.Stdout using Fprintf.
	fmt.Fprintf(os.Stderr, "an %s\n", "error")
}]]>
        </code>
      </module>
      <module name = "Regular Expressions">
        <code><![CDATA[// Go offers built-in support for regular expressions.
// Here are some examples of common regexp-related tasks in Go.
package main

import "bytes"
import "fmt"
import "regexp"

func main() {
	// This tests whether a pattern matches a string.
    match, _ := regexp.MatchString("p([a-z]+)ch", "peach")
    fmt.Println(match)

	// Above we used a string pattern directly, but for other regexp tasks
	// you’ll need to Compile an optimized Regexp struct.
    r, _ := regexp.Compile("p([a-z]+)ch")

	// Many methods are available on these structs. Here’s a match test like we saw earlier.
	fmt.Println(r.MatchString("peach"))

	// This finds the match for the regexp.
	fmt.Println(r.FindString("peach punch"))

	// This also finds the first match but returns the start and end indexes
	// for the match instead of the matching text.
	fmt.Println(r.FindStringIndex("peach punch"))

	// The Submatch variants include information about both the whole-pattern
	// matches and the submatches within those matches. For example this will
	// return information for both p([a-z]+)ch and ([a-z]+).
	fmt.Println(r.FindStringSubmatch("peach punch"))

	// Similarly this will return information about the indexes of matches and submatches.
	fmt.Println(r.FindStringSubmatchIndex("peach punch"))

	// The All variants of these functions apply to all matches in the input,
	// not just the first. For example to find all matches for a regexp.
	fmt.Println(r.FindAllString("peach punch pinch", -1))

	//These All variants are available for the other functions we saw above as well.
	fmt.Println(r.FindAllStringSubmatchIndex( "peach punch pinch", -1))

	// Providing a non-negative integer as the second argument to these functions will limit the number of matches.
	fmt.Println(r.FindAllString("peach punch pinch", 2))

	// Our examples above had string arguments and used names like MatchString.
	// We can also provide []byte arguments and drop String from the function name.
	fmt.Println(r.Match([]byte("peach")))

	// When creating constants with regular expressions you can use the
	// MustCompile variation of Compile. A plain Compile won’t work for
	// constants because it has 2 return values.
	r = regexp.MustCompile("p([a-z]+)ch")
	fmt.Println(r)

	// The regexp package can also be used to replace subsets of strings with other values.
	fmt.Println(r.ReplaceAllString("a peach", "<fruit>"))

	// The Func variant allows you to transform matched text with a given function.
	in := []byte("a peach")
	out := r.ReplaceAllFunc(in, bytes.ToUpper)
	fmt.Println(string(out))
}]]>
        </code>
      </module>
      <module name = "Url parsing">
        <code><![CDATA[// URLs provide a uniform way to locate resources. Here’s how to parse URLs in Go.
package main

import "fmt"
import "net"
import "net/url"

func main() {
	// We’ll parse this example URL, which includes a scheme, authentication info,
	// host, port, path, query params, and query fragment.
    s := "postgres://user:pass@host.com:5432/path?k=v#f"

	// Parse the URL and ensure there are no errors.
	u, err := url.Parse(s)
	if err != nil {
		panic(err)
	}

	// Accessing the scheme is straightforward.
	fmt.Println(u.Scheme)

	// User contains all authentication info; call Username and Password on this for individual values.
	fmt.Println(u.User)
	fmt.Println(u.User.Username())
	p, _ := u.User.Password()
	fmt.Println(p)

	// The Host contains both the hostname and the port, if present. Use SplitHostPort to extract them.
	fmt.Println(u.Host)
	host, port, _ := net.SplitHostPort(u.Host)
	fmt.Println(host)
	fmt.Println(port)

	// Here we extract the path and the fragment after the #.
	fmt.Println(u.Path)
	fmt.Println(u.Fragment)

	// To get query params in a string of k=v format, use RawQuery.
	// You can also parse query params into a map. The parsed query param maps are
	// from strings to slices of strings, so index into [0] if you only want the first value.
	fmt.Println(u.RawQuery)
	m, _ := url.ParseQuery(u.RawQuery)
	fmt.Println(m)
	fmt.Println(m["k"][0])
}

// Running our URL parsing program shows all the different pieces that we extracted.
]]>
        </code>
      </module>
      <module name = "SHA1 Hashes">
        <code><![CDATA[	/* SHA1 hashes are frequently used to compute short identities for binary
or text blobs. For example, the git revision control system uses SHA1s extensively
to identify versioned files and directories. Here’s how to compute SHA1 hashes in Go. */
package main

// Go implements several hash functions in various crypto/* packages.
import "crypto/sha1"
import "fmt"

func main() {
	s := "sha1 this string"

	// The pattern for generating a hash is sha1.New(), sha1.Write(bytes), 
	// then sha1.Sum([]byte{}). Here we start with a new hash.
    h := sha1.New()

	// Write expects bytes. If you have a string s, use []byte(s) to coerce it to bytes.
	h.Write([]byte(s))

	// This gets the finalized hash result as a byte slice. The argument to Sum can be
	// used to append to an existing byte slice: it usually isn’t needed.
	bs := h.Sum(nil)

	// SHA1 values are often printed in hex, for example in git commits. Use the %x format
	// verb to convert a hash results to a hex string.
	fmt.Println(s)
	fmt.Printf("%x\n", bs)
}

	// Running the program computes the hash and prints it in a human-readable hex format.
	// You can compute other hashes using a similar pattern to the one shown above. For
	// example, to compute MD5 hashes import crypto/md5 and use md5.New().
	// Note that if you need cryptographically secure hashes, you should carefully research
	// hash strength!
]]>
        </code>
      </module>
      <module name = "Base64 Encoding">
        <code><![CDATA[package main
// This syntax imports the encoding/base64 package with the b64 name
// instead of the default base64. It’ll save us some space below.

import b64 "encoding/base64"
import "fmt"

func main() {

	// Here’s the string we’ll encode/decode.
	data := "abc123!?$*&()'-=@~"
	// Go supports both standard and URL-compatible base64. Here’s how to encode using
	// the standard encoder. The encoder requires a []byte so we cast our string to that type.

	sEnc := b64.StdEncoding.EncodeToString([]byte(data))
	fmt.Println(sEnc)
	// Decoding may return an error, which you can check if you don’t already
	// know the input to be well-formed.

	sDec, _ := b64.StdEncoding.DecodeString(sEnc)
	fmt.Println(string(sDec))
	fmt.Println()
	// This encodes/decodes using a URL-compatible base64 format.

	uEnc := b64.URLEncoding.EncodeToString([]byte(data))
	fmt.Println(uEnc)
	uDec, _ := b64.URLEncoding.DecodeString(uEnc)
	fmt.Println(string(uDec))
}
// The string encodes to slightly different values with the standard and URL
// base64 encoders (trailing + vs -) but they both decode to the original string as desired.
]]>
        </code>
      </module>
      <module name = "Reading files">
        <code><![CDATA[// Reading and writing files are basic tasks needed for many Go programs.
// First we’ll look at some examples of reading files.
package main
import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"os"
)
	// Reading files requires checking most calls for errors.
	// This helper will streamline our error checks below.
func check(e error) {
	if e != nil {
	panic(e)
	}
}

func main() {
	// Perhaps the most basic file reading task is slurping a file’s entire contents into memory.
	dat, err := ioutil.ReadFile("etutor.ini")
	check(err)
	fmt.Print(string(dat))

	// You’ll often want more control over how and what parts of a file
	// are read. For these tasks, start by Opening a file to obtain an os.File value.
	f, err := os.Open("etutor.ini")
	check(err)

	// Read some bytes from the beginning of the file. Allow up to 5
	// to be read but also note how many actually were read.

	b1 := make([]byte, 5)
	n1, err := f.Read(b1)
	check(err)
	fmt.Printf("%d bytes: %s\n", n1, string(b1))

	// You can also Seek to a known location in the file and Read from there.
	o2, err := f.Seek(6, 0)
	check(err)
	b2 := make([]byte, 2)
	n2, err := f.Read(b2)
	check(err)
	fmt.Printf("%d bytes @ %d: %s\n", n2, o2, string(b2))

	// The io package provides some functions that may be helpful for
	// file reading. For example, reads like the ones above can be more
	// robustly implemented with ReadAtLeast.
	o3, err := f.Seek(6, 0)
	check(err)
	b3 := make([]byte, 2)
	n3, err := io.ReadAtLeast(f, b3, 2)
	check(err)
	fmt.Printf("%d bytes @ %d: %s\n", n3, o3, string(b3))

	// There is no built-in rewind, but Seek(0, 0) accomplishes this.
	_, err = f.Seek(0, 0)
	check(err)

	// The bufio package implements a buffered reader that may be useful
	// both for its efficiency with many small reads and because of the
	// additional reading methods it provides.
	r4 := bufio.NewReader(f)
	b4, err := r4.Peek(5)
	check(err)
	fmt.Printf("5 bytes: %s\n", string(b4))

	// Close the file when you’re done (usually this would be scheduled
	// immediately after Opening with defer).
    f.Close()
}]]>
        </code>
      </module>
  </chapter>
  <chapter name="External GUI" >
    <text>The section is about the External - GUI framework, based on using the GuiServer, external standalone application, which provides GUI service.
This program, Golang Tutor, is written, using this framework.
    </text>
    <module name = "Just a main window">
      <code><![CDATA[package main

import (
	egui "github.com/alkresin/external"
)

func main() {

	// Using of the External GUI framework starts with a call of Init() function
	if egui.Init("") != 0 {
		return
	}

	// Every window and widget must be initialized using Widget structure
	pWindow := &(egui.Widget{X: 100, Y: 100, W: 400, H: 280, Title: "GUI for Golang"})

	// InitMainWindow() starts main window declaration, but doesn't show it on the screen
	egui.InitMainWindow(pWindow)

	// Then may follow menu and widgets declarations

	// Activate() method shows the window on the screen
	// and puts the program to the wait state
	pWindow.Activate()

	// Call Exit() function to close connections and release resourses
	egui.Exit()
}]]>
      </code>
    </module>
    <module name = "Main window with a menu">
      <code><![CDATA[ /* The most complicated thing here is a AddMenuItem() function, which adds a menu item.
It has four parameters: menu item title, menu item identificator, callback function
and callback function string type identificator.
Item id may be needed if it will be used later, for CheckMenuItem(), for example.
If no, you may pass 0 to the AddMenuItem() - it will be generated automatically.
Callback function is the function, which will be called after this menu item will
be choosen. It string identificator is necessary for the framework to find and call this function.
If you set the function to nil, the forth parameter must be a string with a Harbour code,
which will be executed by the GuiServer as a menu item callback function.
So, you have two option to set the callback for a menu item:
 - your Golang function - you pass this function and its id in this case;
 - Harbour code fragment to be executed By the GuiServer - pass nil and this code to the AddMenuItem().
*/
package main

import (
	"time"
	egui "github.com/alkresin/external"
)

func main() {

	if egui.Init("") != 0 {
		return
	}

	pWindow := &(egui.Widget{X: 100, Y: 100, W: 400, H: 280, Title: "GUI for Golang"})
	egui.InitMainWindow(pWindow)

	// Main menu declaration begins with a call of a Menu("") function
	// with an empty menu title
	egui.Menu("")
	{
		// The submenu has a name. I use blocks {} here for better formatting only
		egui.Menu("File")
		{
			// Adding menu items and a separator
			// We set a fu1() as a callback here
			egui.AddMenuItem("Date", 0, fu1, "fu1" )
			egui.AddMenuSeparator()
			// We set a Harbour code as a callback here - 
			//   it is a HwGUI function, which closes the main window
			egui.AddMenuItem("Exit", 0, nil, "hwg_EndWindow()")
		}
		egui.EndMenu()
		egui.Menu("Help")
		{
			egui.AddMenuItem("About", 0, nil,
				"hwg_MsgInfo(\"My Golang GUI application\"+chr(10)+chr(13)+hwg_version(),\"About\")")
		}
		egui.EndMenu()
	}
	egui.EndMenu()

	pWindow.Activate()
	egui.Exit()
}

func fu1([]string) string {

	egui.MsgInfo("Today is " + time.Now().Format("02.01.2006"), "Info", nil, "", "")
	return ""
}]]>
      </code>
    </module>
    <module name = "Window with widgets">
      <code><![CDATA[/* */
package main

import (
	egui "github.com/alkresin/external"
)

func main() {

	if egui.Init("") != 0 {
		return
	}

	pWindow := &(egui.Widget{X: 100, Y: 100, W: 300, H: 200, Title: "GUI for Golang"})
	egui.InitMainWindow(pWindow)

	pWindow.AddWidget(&(egui.Widget{Type: "label",
		X: 20, Y: 20, W: 180, H: 24, Title: "Test of a label",
		AProps: map[string]string{"Transpa": "t"}}))

	pWindow.AddWidget(&(egui.Widget{Type: "edit", X: 20, Y: 44, W: 180, H: 24}))

	pWindow.AddWidget(&(egui.Widget{Type: "button", X: 100, Y: 120, W: 100, H: 32, Title: "Ok"}))
	egui.PLastWidget.SetCallBackProc("onclick", nil, "hwg_EndWindow()")

	pWindow.Activate()

	egui.Exit()
}]]>
      </code>
    </module>
    <module name = "Standard dialogs">
      <code><![CDATA[ /* This is about standard dialogs: messageboxes, file, color and font
selections and two HwGUI dialogs - MsgGet and Choice.
NOTE: your program doesn't stop after calling these dialogs, doesn't wait for a result,
and you can not write:
  bYes := egui.MsgYesNo( ... )
So, how to return results from them? External is event-driven framework. It calls
the dialog with parameters, which defines, what function should be called to get results,
when they will be ready. These are last three parameters in each oh those functions,
which provides this functionality:
  fu func([]string) string, sFunc string, sName string
First and second, fu and sFunc are a function and it identifier - see the 
"Main window with a menu" for more explanations. Third, sName, is passed
to the callback function - you will see in a sample how it may be used.
 */
package main

import (
	egui "github.com/alkresin/external"
)

func main() {

	if egui.Init("") != 0 {
		return
	}

	pWindow := &(egui.Widget{X: 100, Y: 100, W: 400, H: 380, Title: "Standard dialogs"})
	egui.InitMainWindow(pWindow)

	pWindow.AddWidget(&(egui.Widget{Type: "button", X: 40, Y: 30, W: 150, H: 32, Title: "MsgInfo"}))
	egui.PLastWidget.SetCallBackProc("onclick", fmsginf, "fmsginf")

	pWindow.AddWidget(&(egui.Widget{Type: "button", X: 40, Y: 70, W: 150, H: 32, Title: "MsgStop"}))
	egui.PLastWidget.SetCallBackProc("onclick", fmsgstop, "fmsgstop")

	pWindow.AddWidget(&(egui.Widget{Type: "button", X: 40, Y: 110, W: 150, H: 32, Title: "MsgYesNo"}))
	egui.PLastWidget.SetCallBackProc("onclick", fmsgyes, "fmsgyes")

	pWindow.AddWidget(&(egui.Widget{Type: "button", X: 40, Y: 150, W: 150, H: 32, Title: "MsgGet"}))
	egui.PLastWidget.SetCallBackProc("onclick", fmsgget, "fmsgget")

	pWindow.AddWidget(&(egui.Widget{Type: "button", X: 40, Y: 190, W: 150, H: 32, Title: "Choice"}))
	egui.PLastWidget.SetCallBackProc("onclick", fcho, "fcho")

	pWindow.AddWidget(&(egui.Widget{Type: "button", X: 40, Y: 230, W: 150, H: 32, Title: "SelectColor"}))
	egui.PLastWidget.SetCallBackProc("onclick", fselclr, "fselclr")

	pWindow.AddWidget(&(egui.Widget{Type: "button", X: 40, Y: 270, W: 150, H: 32, Title: "SelectFont"}))
	egui.PLastWidget.SetCallBackProc("onclick", fselfnt, "fselfnt")

	pWindow.AddWidget(&(egui.Widget{Type: "button", X: 40, Y: 310, W: 150, H: 32, Title: "SelectFile"}))
	egui.PLastWidget.SetCallBackProc("onclick", fselfile, "fselfile")

	pWindow.Activate()
	egui.Exit()
}

func fmsginf([]string) string {

	egui.MsgInfo("MsgInfo Messagebox", "Info", nil, "", "")
	return ""
}

func fmsgstop([]string) string {

	egui.MsgStop("MsgStop Messagebox", "Info", nil, "", "")
	return ""
}

func fmsgyes(p []string) string {

	// If this function is called after pressing the button "MsgYesNo",
	// the first item in a passed slice will be the full button name ("main."+...)
	if len(p[0]) > 4 && p[0][:5] == "main." {
		// We set this function as callback again and set the parameter "mm1"
		egui.MsgYesNo("MsgYesNo Messagebox", "Question", fmsgyes, "fmsgyes", "mm1")
	} else if p[0] == "mm1" {
		// and after the messagebox will be closed, this function is called again
		// with the first item in a passed slice - "mm1"
		// and the second item - the result, returned by the messagebox.
		if p[1] == "t" {
			egui.MsgInfo("Yes!", "Answer", nil, "", "")
		} else {
			egui.MsgInfo("No...", "Answer", nil, "", "")
		}
	}
	return ""
}

func fmsgget(p []string) string {
	if len(p[0]) > 4 && p[0][:5] == "main." {
		egui.MsgGet("Input something:", "MsgGet", 0, fmsgget, "fmsgget", "mm1")
	} else if p[0] == "mm1" {
		egui.MsgInfo(p[1], "Answer", nil, "", "")
	}
	return ""
}

func fcho(p []string) string {
	if len(p[0]) > 4 && p[0][:5] == "main." {
		arr := []string{"Alex Petrov", "Serg Lama", "Jimmy Hendrix", "Dorian Gray", "Victor Peti"}
		egui.Choice(arr, "Select from a list", fcho, "fcho", "mm1")
	} else if p[0] == "mm1" {
		egui.MsgInfo(p[1], "Answer", nil, "", "")
	}
	return ""
}

func fselclr(p []string) string {
	if len(p[0]) > 4 && p[0][:5] == "main." {
		egui.SelectColor(0, fselclr, "fselclr", "mm1")
	} else {
		egui.MsgInfo(p[1], "Answer", nil, "", "")
	}
	return ""
}

func fselfnt(p []string) string {
	if len(p[0]) > 4 && p[0][:5] == "main." {
		egui.SelectFont(fselfnt, "fselfnt", "")
	} else {
		if pFont := egui.GetFont(p[0]); pFont != nil {
			if len(p) < 8 {
				egui.MsgInfo("Nothing selected", "Font", nil, "", "")
			} else {
				egui.MsgInfo("Family: "+p[1], "Font", nil, "", "")
			}
		}
	}
	return ""
}

func fselfile(p []string) string {
	if len(p[0]) > 4 && p[0][:5] == "main." {
		egui.SelectFile("", fselfile, "fselfile", "mm1")
	} else {
		if p[1] == "" {
			egui.MsgInfo("Nothing selected", "Result", nil, "", "")
		} else {
			egui.MsgInfo(p[1], "File selected", nil, "", "")
		}
	}
	return ""
}
]]>
      </code>
    </module>
    <module name = "Icon, tray">
      <code><![CDATA[ /* NOTE: This is a Windows only sample, tray isn't supported in GTK version.
Here we meet new kind of menu - context. It may be used not for tray only,
but, as usually, to be called when it is needed - after a button click, for example */
package main

import (
	egui "github.com/alkresin/external"
)

var bOkIcon = false

func main() {

	if egui.Init("") != 0 {
		return
	}

	// Set the path, where GuiServer will look for image files
	egui.SetImagePath("images/")

	// We define here an icon name for a window. It is without an extension, so
	// Windows version will use etutor.ico, while GTK version - etutor.png
	pWindow := &(egui.Widget{X: 100, Y: 100, W: 300, H: 180, Title: "External tray sample",
		AProps: map[string]string{"Icon": "etutor"}})
	egui.InitMainWindow(pWindow)

	pWindow.AddWidget(&(egui.Widget{Type: "label", Winstyle: egui.DT_CENTER,
		X: 20, Y: 40, W: 260, H: 24, Title: "Use 'Change icon' tray menu item",
		AProps: map[string]string{"Transpa": "t"}}))

	pWindow.AddWidget(&(egui.Widget{Type: "label", Winstyle: egui.DT_CENTER,
		X: 20, Y: 64, W: 260, H: 24, Title: "to modify the icon",
		AProps: map[string]string{"Transpa": "t"}}))

	egui.MenuContext("cm")
	{
		egui.AddMenuItem("Restore window", 0, nil, "HWindow():GetMain():Restore()" )
		egui.AddMenuItem("Change icon", 0, ficon, "ficon")
		egui.AddMenuSeparator()
		egui.AddMenuItem("About", 0, nil,
			"hwg_MsgInfo(\"My Golang GUI application\"+chr(10)+chr(13)+hwg_version(),\"About\")")
		egui.AddMenuItem("Exit", 0, nil, "hwg_EndWindow()")
	}
	egui.EndMenu()

	// Place the window to tray, "cm" - a name of context menu, which we created above,
	// the third string parameter is a tooltip of a tray icon.
	egui.InitTray("","cm","External tray sample")

	pWindow.Activate()
	egui.Exit()
}

func ficon([]string) string {
	if bOkIcon {
		egui.ModifyTrayIcon("etutor")
		bOkIcon = false
	} else {
		egui.ModifyTrayIcon("ok")
		bOkIcon = true
	}
	return ""
}
]]>
      </code>
    </module>
  </chapter>
</init>